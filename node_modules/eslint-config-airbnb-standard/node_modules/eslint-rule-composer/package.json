{
  "_from": "eslint-rule-composer@^0.3.0",
  "_id": "eslint-rule-composer@0.3.0",
  "_inBundle": false,
  "_integrity": "sha512-bt+Sh8CtDmn2OajxvNO+BX7Wn4CIWMpTRm3MaiKPCQcnnlm0CS2mhui6QaoeQugs+3Kj2ESKEEGJUdVafwhiCg==",
  "_location": "/eslint-config-airbnb-standard/eslint-rule-composer",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "eslint-rule-composer@^0.3.0",
    "name": "eslint-rule-composer",
    "escapedName": "eslint-rule-composer",
    "rawSpec": "^0.3.0",
    "saveSpec": null,
    "fetchSpec": "^0.3.0"
  },
  "_requiredBy": [
    "/eslint-config-airbnb-standard/eslint-plugin-babel"
  ],
  "_resolved": "https://registry.npmjs.org/eslint-rule-composer/-/eslint-rule-composer-0.3.0.tgz",
  "_shasum": "79320c927b0c5c0d3d3d2b76c8b4a488f25bbaf9",
  "_shrinkwrap": null,
  "_spec": "eslint-rule-composer@^0.3.0",
  "_where": "/home/ITRANSITION.CORP/r.hodko/Projects/eslint-config-airbnb-standard/node_modules/eslint-plugin-babel",
  "author": {
    "name": "Teddy Katz"
  },
  "bugs": {
    "url": "https://github.com/not-an-aardvark/eslint-rule-composer/issues"
  },
  "bundleDependencies": false,
  "dependencies": {},
  "deprecated": false,
  "description": "A utility for composing ESLint rules from other ESLint rules",
  "devDependencies": {
    "@not-an-aardvark/node-release-script": "^0.1.0",
    "chai": "^4.1.2",
    "eslint": "^4.7.1",
    "eslint-config-airbnb-base": "^12.0.0",
    "eslint-plugin-import": "^2.7.0",
    "eslint-plugin-node": "^5.1.1",
    "mocha": "^3.5.3"
  },
  "engines": {
    "node": ">=4.0.0"
  },
  "files": [
    "lib/"
  ],
  "homepage": "https://github.com/not-an-aardvark/eslint-rule-composer#readme",
  "keywords": [
    "eslint"
  ],
  "license": "MIT",
  "main": "lib/rule-composer.js",
  "name": "eslint-rule-composer",
  "optionalDependencies": {},
  "readme": "# eslint-rule-composer\n\nThis is a utility that allows you to build [ESLint](https://eslint.org/) rules out of other ESLint rules.\n\n## Installation\n\n```\nnpm install eslint-rule-composer --save\n```\n\nRequires Node 4 or later.\n\n## Examples\n\nThe following example creates a modified version of the [`no-unused-expressions`](https://eslint.org/docs/rules/no-unused-expressions) rule which does not report lines starting with `expect`.\n\n```js\nconst ruleComposer = require('eslint-rule-composer');\nconst eslint = require('eslint');\nconst noUnusedExpressionsRule = new eslint.Linter().getRules().get('no-unused-expressions');\n\nmodule.exports = ruleComposer.filterReports(\n  noUnusedExpressionsRule,\n  (problem, metadata) => metadata.sourceCode.getFirstToken(problem.node).value !== 'expect'\n);\n```\n\nThe following example creates a modified version of the [`semi`](https://eslint.org/docs/rules/semi) rule which reports missing semicolons after experimental class properties:\n\n```js\nconst ruleComposer = require('eslint-rule-composer');\nconst eslint = require('eslint');\nconst semiRule = new eslint.Linter().getRules().get('semi');\n\nmodule.exports = ruleComposer.joinReports([\n  semiRule,\n  context => ({\n    ClassProperty(node) {\n      if (context.getSourceCode().getLastToken(node).value !== ';') {\n        context.report({ node, message: 'Missing semicolon.' })\n      }\n    }\n  })\n]);\n```\n\nYou can access rule's options and [shared settings](https://eslint.org/docs/user-guide/configuring#adding-shared-settings) from the current ESLint configuration. The following example creates a modified version of the [`no-unused-expressions`](https://eslint.org/docs/rules/no-unused-expressions) rule which accepts a list of exceptions.\n\n```js\n\n/*\n  rule configuration:\n\n  {\n    \"custom-no-unused-expressions\": [\"error\", {\n      \"whitelist\": [\"expect\", \"test\"]\n    }]\n  }\n*/\n\nconst ruleComposer = require('eslint-rule-composer');\nconst eslint = require('eslint');\nconst noUnusedExpressionsRule = new eslint.Linter().getRules().get('no-unused-expressions');\n\nmodule.exports = ruleComposer.filterReports(\n  noUnusedExpressionsRule,\n  (problem, metadata) => {\n    const firstToken = metadata.sourceCode.getFirstToken(problem.node);\n    const whitelist = metadata.options[0].whitelist;\n    return whitelist.includes(value) === false\n  }\n);\n```\n\n## API\n\n### `ruleComposer.filterReports(rule, predicate)` and `ruleComposer.mapReports(rule, predicate)`\n\nBoth of these functions accept two arguments: `rule` (an ESLint rule object) and `predicate` (a function)\n\n`filterReports(rule, predicate)` returns a new rule such that whenever the original rule would have reported a problem, the new rule will report a problem only if `predicate` returns true for that problem.\n`mapReports(rule, predicate)` returns a new rule such that whenever the original rule would have reported a problem, the new rule reports the result of calling `predicate` on the problem.\n\nIn both cases, `predicate` is called with two arguments: `problem` and `metadata`.\n\n* `problem` is a normalized representation of a problem reported by the original rule. This has the following schema:\n\n    ```\n    {\n      node: ASTNode | null,\n      message: string,\n      messageId: string | null,\n      data: Object | null,\n      loc: {\n        start: { line: number, column: number },\n        end: { line: number, column: number } | null\n      },\n      fix: Function\n    }\n    ```\n\n    Note that the `messageId` and `data` properties will only be present if the original rule reported a problem using [Message IDs](https://eslint.org/docs/developer-guide/working-with-rules#messageids), otherwise they will be null.\n\n    When returning a descriptor with `mapReports`, the `messageId` property on the returned descriptor will be used to generate the new message. To modify a report message directly for a rule that uses message IDs, ensure that the `predicate` function returns an object without a `messageId` property.\n* `metadata` is an object containing information about the source text that was linted. This has the following properties:\n\n* `sourceCode`: a [`SourceCode`](https://eslint.org/docs/developer-guide/working-with-rules#contextgetsourcecode) instance corresponding to the linted text.\n* `settings`: linter instance's [shared settings](https://eslint.org/docs/user-guide/configuring#adding-shared-settings)\n* `options`: rule's [configuration options](https://eslint.org/docs/developer-guide/working-with-rules#contextoptions)\n* `filename`: corresponding filename for the linted text.\n\n### `ruleComposer.joinReports(rules)`\n\nGiven an array of ESLint rule objects, `joinReports` returns a new rule that will report all of the problems from any of the rules in the array. The options provided to the new rule will also be provided to all of the rules in the array.\n\n### Getting a reference to an ESLint rule\n\nTo get a reference to an ESLint core rule, you can use ESLint's [public API](https://eslint.org/docs/developer-guide/nodejs-api) like this:\n\n```js\n// get a reference to the 'semi' rule\n\nconst eslint = require('eslint');\nconst semiRule = new eslint.Linter().getRules().get('semi');\n```\n\nTo get a reference to a rule from a plugin, you can do this:\n\n```js\n// get a reference to the 'react/boolean-prop-naming' rule\nconst booleanPropNamingRule = require('eslint-plugin-react').rules['boolean-prop-naming'];\n```\n\nYou can also create your own rules (see the [rule documentation](https://eslint.org/docs/developer-guide/working-with-rules)):\n\n```js\nconst myCustomRule = {\n  create(context) {\n    return {\n      DebuggerStatement(node) {\n        context.report({ node, message: 'Do not use debugger statements.' });\n      }\n    }\n  }\n};\n```\n\n## License\n\nMIT License\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/not-an-aardvark/eslint-rule-composer.git"
  },
  "scripts": {
    "generate-release": "node-release-script",
    "lint": "eslint lib/ tests/",
    "test": "npm run lint && mocha tests/**/*.js"
  },
  "version": "0.3.0"
}
